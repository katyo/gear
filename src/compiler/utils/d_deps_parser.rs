use crate::{qjs, Error, Result, Set};
use nom::{
    branch::alt,
    bytes::complete::{tag, take_while1},
    character::complete::{char, line_ending, not_line_ending, space0, space1},
    combinator::{all_consuming, eof, iterator, map, not, opt, value},
    multi::separated_list1,
    sequence::{delimited, terminated, tuple},
    Err as IErr, IResult,
};
use std::str::FromStr;

#[derive(Debug, Clone, PartialEq, Eq, Hash, qjs::IntoJs)]
pub struct DDepsInfo {
    pub deps: Vec<DDepInfo>,
}

impl FromStr for DDepsInfo {
    type Err = Error;

    /// Parse dependencies generated by the compiler
    fn from_str(input: &str) -> Result<Self> {
        Ok(all_consuming(Self::parse_deps)(input)
            .map_err(|error| match error {
                IErr::Error(error) => error.input,
                IErr::Failure(error) => error.input,
                _ => unreachable!(),
            })
            .map_err(|input| format!("Error while parsing D deps: `{}`", input))?
            .1)
    }
}

impl DDepsInfo {
    pub fn dep_sources(&self) -> Set<String> {
        self.deps.iter().map(|dep| dep.dep_source.clone()).collect()
    }

    fn parse_deps(input: &str) -> IResult<&str, Self> {
        let mut iter = iterator(input, Self::parse_dep);
        let deps = iter.filter_map(|v| v).collect();
        let (input, _) = iter.finish()?;
        Ok((input, Self { deps }))
    }

    fn parse_dep(input: &str) -> IResult<&str, Option<DDepInfo>> {
        not(eof)(input)?;
        terminated(
            alt((map(DDepInfo::parse_dep, Some), value(None, not_line_ending))),
            alt((line_ending, eof)),
        )(input)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, qjs::IntoJs)]
pub struct DDepInfo {
    pub module: String,
    pub source: String,
    pub public: bool,
    pub static_: bool,
    pub dep_module: String,
    pub dep_source: String,
    // TODO:
    pub import: DDepImports,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, qjs::IntoJs)]
pub enum DDepImports {
    Module,                   // ``
    ModuleAs(String),         // ` -> name`
    Entries(Vec<DDepImport>), // `: name,...`
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, qjs::IntoJs)]
pub enum DDepImport {
    Entry(String),           // `name`
    EntryAs(String, String), // `as = name`
}

impl FromStr for DDepInfo {
    type Err = Error;

    /// Parse dependency generated by the compiler
    fn from_str(input: &str) -> Result<Self> {
        Ok(all_consuming(Self::parse_dep)(input)
            .map_err(|error| match error {
                IErr::Error(error) => error.input,
                IErr::Failure(error) => error.input,
                _ => unreachable!(),
            })
            .map_err(|input| format!("Error while parsing D dep: `{}`", input))?
            .1)
    }
}

impl DDepInfo {
    fn parse_dep(input: &str) -> IResult<&str, Self> {
        map(
            tuple((
                module_name,
                space0,
                source_path,
                space0,
                colon,
                space0,
                access_spec,
                static_spec,
                space0,
                colon,
                space0,
                module_name,
                space0,
                source_path,
                module_imports,
            )),
            |(
                module,
                _,
                source,
                _,
                _,
                _,
                public,
                static_,
                _,
                _,
                _,
                dep_module,
                _,
                dep_source,
                import,
            )| Self {
                module,
                source,
                public,
                static_,
                dep_module,
                dep_source,
                import,
            },
        )(input)
    }
}

fn colon(input: &str) -> IResult<&str, ()> {
    value((), char(':'))(input)
}

fn arrow(input: &str) -> IResult<&str, ()> {
    value((), tag("->"))(input)
}

fn module_name(input: &str) -> IResult<&str, String> {
    map(
        take_while1(|c: char| !c.is_whitespace() && c != '('),
        |input: &str| input.into(),
    )(input)
}

fn source_path(input: &str) -> IResult<&str, String> {
    map(
        delimited(char('('), take_while1(|c: char| c != ')'), char(')')),
        |name: &str| name.into(),
    )(input)
}

fn access_spec(input: &str) -> IResult<&str, bool> {
    map(alt((tag("public"), tag("private"))), |access: &str| {
        access.ends_with("c")
    })(input)
}

fn static_spec(input: &str) -> IResult<&str, bool> {
    map(opt(tuple((space1, tag("static")))), |access: Option<_>| {
        access.is_some()
    })(input)
}

fn import_module_as(input: &str) -> IResult<&str, String> {
    map(
        tuple((
            space0,
            arrow,
            space0,
            take_while1(|c: char| !c.is_whitespace() && c != ',' && c != '='),
        )),
        |(_, _, _, name)| name.into(),
    )(input)
}

fn import_entries(input: &str) -> IResult<&str, Vec<DDepImport>> {
    map(
        tuple((
            space0,
            colon,
            space0,
            separated_list1(
                tuple((space0, char(','), space0)),
                map(
                    tuple((
                        take_while1(|c: char| !c.is_whitespace() && c != ',' && c != '='),
                        opt(tuple((
                            space0,
                            char('='),
                            space0,
                            take_while1(|c: char| !c.is_whitespace() && c != ','),
                        ))),
                    )),
                    |(first, second): (&str, Option<(_, _, _, &str)>)| {
                        second
                            .map(|second| DDepImport::EntryAs(second.3.into(), first.into()))
                            .unwrap_or_else(|| DDepImport::Entry(first.into()))
                    },
                ),
            ),
        )),
        |(_, _, _, entries)| entries,
    )(input)
}

fn module_imports(input: &str) -> IResult<&str, DDepImports> {
    map(
        opt(alt((
            map(import_module_as, DDepImports::ModuleAs),
            map(import_entries, DDepImports::Entries),
        ))),
        |imports| imports.unwrap_or_else(|| DDepImports::Module),
    )(input)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn deps_empty() {
        let txt = "";
        let deps = txt.parse::<DDepsInfo>().unwrap();
        assert_eq!(deps, DDepsInfo { deps: vec![] })
    }

    #[test]
    fn deps_multi() {
        let txt = r#"std.array (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/array.d) : private : std.traits (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/traits.d)
std.array (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/array.d) : private : std.range.primitives (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/primitives.d)
std.array (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/array.d) : public : std.range.primitives (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/primitives.d):save,empty,popFront,popBack,front,back
std.range (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/package.d) : public : std.array (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/array.d)
std.range.interfaces (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/interfaces.d) : private : object (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/object.d)
std.range.interfaces (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/interfaces.d) : private : std.meta (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/meta.d)
std.range.interfaces (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/interfaces.d) : private : std.range.primitives (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/primitives.d)
std.range.interfaces (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/interfaces.d) : private : std.traits (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/traits.d)
std.range (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/package.d) : public : std.range.interfaces (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/interfaces.d)
std.range (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/package.d) : public : std.range.primitives (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/primitives.d)
std.typecons (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/typecons.d) : private : object (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/object.d)"#;
        let deps = txt.parse::<DDepsInfo>().unwrap();
        assert_eq!(deps.deps.len(), 11);
        let srcs = deps.dep_sources();
        assert_eq!(srcs.len(), 6);
        assert_eq!(
            srcs[0],
            "/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/traits.d"
        );
        assert_eq!(srcs[1], "/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/primitives.d");
        assert_eq!(
            srcs[2],
            "/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/array.d"
        );
        assert_eq!(
            srcs[3],
            "/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/object.d"
        );
        assert_eq!(
            srcs[4],
            "/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/meta.d"
        );
        assert_eq!(srcs[5], "/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/std/range/interfaces.d");
    }

    #[test]
    fn dep_import_module() {
        let txt = "traits (uctl/traits.d) : private : object (/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/object.d)";
        let dep = txt.parse::<DDepInfo>().unwrap();
        assert_eq!(
            dep,
            DDepInfo {
                module: "traits".into(),
                source: "uctl/traits.d".into(),
                public: false,
                static_: false,
                dep_module: "object".into(),
                dep_source:
                    "/nix/store/9rc2ci66nxa0ljplqlimy52wb1rgkvwm-ldc-1.24.0/include/d/object.d"
                        .into(),
                import: DDepImports::Module,
            }
        );
    }

    #[test]
    fn dep_import_entries() {
        let txt = "std.traits (/nix/store/3af1vak40yz5rp0qcsdz1nv34ayr0pg9-ldc-1.25.0-beta1/include/d/std/traits.d) : private : core.internal.traits (/nix/store/3af1vak40yz5rp0qcsdz1nv34ayr0pg9-ldc-1.25.0-beta1/include/d/core/internal/traits.d):Unsigned,CoreUnqual=Unqual,isSigned";
        let dep = txt.parse::<DDepInfo>().unwrap();
        assert_eq!(
            dep,
            DDepInfo {
                module: "std.traits".into(),
                source: "/nix/store/3af1vak40yz5rp0qcsdz1nv34ayr0pg9-ldc-1.25.0-beta1/include/d/std/traits.d".into(),
                public: false,
                static_: false,
                dep_module: "core.internal.traits".into(),
                dep_source:
                "/nix/store/3af1vak40yz5rp0qcsdz1nv34ayr0pg9-ldc-1.25.0-beta1/include/d/core/internal/traits.d"
                        .into(),
                import: DDepImports::Entries(vec![
                    DDepImport::Entry("Unsigned".into()),
                    DDepImport::EntryAs("Unqual".into(), "CoreUnqual".into()),
                    DDepImport::Entry("isSigned".into()),
                ]),
            }
        );
    }

    #[test]
    fn dep_import_module_as() {
        let txt =
            "uctl.util (uctl/util/package.d) : public : uctl.util.osc (uctl/util/osc.d) -> OSC";
        let dep = txt.parse::<DDepInfo>().unwrap();
        assert_eq!(
            dep,
            DDepInfo {
                module: "uctl.util".into(),
                source: "uctl/util/package.d".into(),
                public: true,
                static_: false,
                dep_module: "uctl.util.osc".into(),
                dep_source: "uctl/util/osc.d".into(),
                import: DDepImports::ModuleAs("OSC".into()),
            }
        );
    }
}
