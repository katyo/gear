use crate::{qjs, Error, Result, Set};
use nom::{
    branch::alt,
    bytes::complete::{escaped, escaped_transform, tag},
    character::complete::{none_of, one_of},
    combinator::{eof, map, not, opt, value},
    multi::separated_list0,
    sequence::tuple,
    Err as IErr, IResult,
};
use std::str::FromStr;

#[derive(Debug, Clone, qjs::IntoJs)]
pub struct DepsInfo {
    pub name: String,
    pub deps: Set<String>,
}

impl FromStr for DepsInfo {
    type Err = Error;

    /// Parse dependencies generated by the compiler
    fn from_str(input: &str) -> Result<Self> {
        let (input, result) = Self::parse_deps(input)
            .map_err(|error| match error {
                IErr::Error(error) => error.input,
                IErr::Failure(error) => error.input,
                _ => unreachable!(),
            })
            .map_err(|input| format!("Error when parsing deps: `{}`", input))?;
        if input.is_empty() {
            Ok(result)
        } else {
            Err(format!("Error when parsing deps: `{}`", input).into())
        }
    }
}

fn space(input: &str) -> IResult<&str, ()> {
    not(eof)(input)?;
    map(escaped(one_of(" \t\r\n"), '\\', one_of("\\\r\n")), |_| ())(input)
}

fn colon(input: &str) -> IResult<&str, ()> {
    map(tag(":"), |_| ())(input)
}

fn filename(input: &str) -> IResult<&str, String> {
    not(eof)(input)?;
    escaped_transform(
        none_of(":\\ \t\r\n"),
        '\\',
        alt((
            value(":", tag(":")),
            value("\\", tag("\\")),
            value(" ", tag(" ")),
            value("t", tag("\t")),
            value("r", tag("\r")),
            value("n", tag("\n")),
        )),
    )(input)
}

impl DepsInfo {
    fn parse_deps(input: &str) -> IResult<&str, Self> {
        map(
            tuple((
                opt(space),
                filename,
                opt(space),
                colon,
                opt(space),
                separated_list0(space, filename),
                opt(space),
            )),
            |(_, name, _, _, _, deps, _)| Self {
                name: name.into(),
                deps: deps.into_iter().collect(),
            },
        )(input)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    mod space {
        use super::*;

        #[test]
        fn single() {
            assert_eq!(space(" _"), Ok(("_", ())));
        }

        #[test]
        fn multiple() {
            assert_eq!(space("  \t _"), Ok(("_", ())));
        }

        #[test]
        fn escaped() {
            assert_eq!(space(" \\\r\n\t \\\n _"), Ok(("_", ())));
        }

        #[test]
        #[should_panic(expected = r#"Error(Error { input: "_", code: Escaped })"#)]
        fn none() {
            let _ = space("_").map_err(|error| panic!("{:?}", error));
        }

        #[test]
        #[should_panic(expected = r#"Error(Error { input: "", code: Not })"#)]
        fn empty() {
            let _ = space("").map_err(|error| panic!("{:?}", error));
        }
    }

    mod filename {
        use super::*;

        #[test]
        fn simple() {
            assert_eq!(
                filename("test.o: test.c"),
                Ok((": test.c", "test.o".into()))
            );
        }

        #[test]
        fn escaped() {
            assert_eq!(
                filename("test\\ file.o: test\\ file.c"),
                Ok((": test\\ file.c", "test file.o".into()))
            );
        }

        #[test]
        fn escaped2() {
            assert_eq!(filename("\\\\test.o "), Ok((" ", "\\test.o".into())));
        }

        #[test]
        fn padded() {
            assert_eq!(
                filename("test\\ file.o : test\\ file.c"),
                Ok((" : test\\ file.c", "test file.o".into()))
            );
        }

        #[test]
        #[should_panic(
            expected = r#"Parsing Error: Error { input: " test.o ", code: EscapedTransform }"#
        )]
        fn none() {
            let _ = filename(" test.o ").map_err(|error| panic!("{}", error));
        }

        #[test]
        #[should_panic(expected = r#"Error(Error { input: "", code: Not })"#)]
        fn empty() {
            let _ = filename("").map_err(|error| panic!("{:?}", error));
        }
    }

    mod parse {
        use super::*;

        #[test]
        fn single_line() {
            let info: DepsInfo = "test.o: test.c test.h".parse().unwrap();
            assert_eq!(info.name, "test.o");
            assert_eq!(info.deps.len(), 2);
            assert_eq!(&info.deps[0], "test.c");
            assert_eq!(&info.deps[1], "test.h");
        }

        #[test]
        fn multi_line() {
            let info: DepsInfo = r#"test.o: test.c   \
 /usr/include/json/json\ parser.h \
 /usr/include/stdio.h     \
   ../includes/config.h test.h
"#
            .parse()
            .unwrap();
            assert_eq!(info.name, "test.o");
            assert_eq!(info.deps.len(), 5);
            assert_eq!(&info.deps[0], "test.c");
            assert_eq!(&info.deps[1], "/usr/include/json/json parser.h");
            assert_eq!(&info.deps[2], "/usr/include/stdio.h");
            assert_eq!(&info.deps[3], "../includes/config.h");
            assert_eq!(&info.deps[4], "test.h");
        }
    }
}
