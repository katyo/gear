use nom::{
    branch::alt,
    bytes::complete::{escaped, escaped_transform, tag},
    character::complete::{none_of, one_of},
    combinator::{eof, map, not, opt, value},
    multi::separated_list0,
    sequence::tuple,
    Err as IErr, IResult,
};
use crate::Result;

fn space(input: &str) -> IResult<&str, ()> {
    not(eof)(input)?;
    map(escaped(one_of(" \t\r\n"), '\\', one_of("\\\r\n")), |_| ())(input)
}

fn colon(input: &str) -> IResult<&str, ()> {
    map(tag(":"), |_| ())(input)
}

fn filename(input: &str) -> IResult<&str, String> {
    not(eof)(input)?;
    escaped_transform(
        none_of(":\\ \t\r\n"),
        '\\',
        alt((
            value(":", tag(":")),
            value("\\", tag("\\")),
            value(" ", tag(" ")),
            value("t", tag("\t")),
            value("r", tag("\r")),
            value("n", tag("\n")),
        )),
    )(input)
}

fn deps(input: &str) -> IResult<&str, (String, Vec<String>)> {
    map(
        tuple((
            opt(space),
            filename,
            opt(space),
            colon,
            opt(space),
            separated_list0(space, filename),
            opt(space),
        )),
        |(_, target, _, _, _, deps, _)| (target, deps),
    )(input)
}

/// Parse dependencies generated by the compiler
pub fn parse_deps(input: &str) -> Result<(String, Vec<String>)> {
    let (input, result) = deps(input).map_err(|error| match error {
        IErr::Error(error) => error.input,
        IErr::Failure(error) => error.input,
        _ => unreachable!(),
    }).map_err(|input| format!("Error when parsing deps: `{}`", input))?;
    if input.is_empty() {
        Ok(result)
    } else {
        Err(format!("Error when parsing deps: `{}`", input).into())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    mod space {
        use super::*;

        #[test]
        fn single() {
            assert_eq!(space(" _"), Ok(("_", ())));
        }

        #[test]
        fn multiple() {
            assert_eq!(space("  \t _"), Ok(("_", ())));
        }

        #[test]
        fn escaped() {
            assert_eq!(space(" \\\r\n\t \\\n _"), Ok(("_", ())));
        }

        #[test]
        #[should_panic(expected = r#"Error(Error { input: "_", code: Escaped })"#)]
        fn none() {
            let _ = space("_").map_err(|error| panic!("{:?}", error));
        }

        #[test]
        #[should_panic(expected = r#"Error(Error { input: "", code: Not })"#)]
        fn empty() {
            let _ = space("").map_err(|error| panic!("{:?}", error));
        }
    }

    mod filename {
        use super::*;

        #[test]
        fn simple() {
            assert_eq!(
                filename("test.o: test.c"),
                Ok((": test.c", "test.o".into()))
            );
        }

        #[test]
        fn escaped() {
            assert_eq!(
                filename("test\\ file.o: test\\ file.c"),
                Ok((": test\\ file.c", "test file.o".into()))
            );
        }

        #[test]
        fn escaped2() {
            assert_eq!(filename("\\\\test.o "), Ok((" ", "\\test.o".into())));
        }

        #[test]
        fn padded() {
            assert_eq!(
                filename("test\\ file.o : test\\ file.c"),
                Ok((" : test\\ file.c", "test file.o".into()))
            );
        }

        #[test]
        #[should_panic(
            expected = r#"Parsing Error: Error { input: " test.o ", code: EscapedTransform }"#
        )]
        fn none() {
            let _ = filename(" test.o ").map_err(|error| panic!("{}", error));
        }

        #[test]
        #[should_panic(expected = r#"Error(Error { input: "", code: Not })"#)]
        fn empty() {
            let _ = filename("").map_err(|error| panic!("{:?}", error));
        }
    }

    mod parse {
        use super::*;

        #[test]
        fn case0() {
            let (target, deps) = parse_deps("test.o: test.c test.h").unwrap();
            assert_eq!(target, "test.o");
            assert_eq!(deps.len(), 2);
            assert_eq!(&deps[0], "test.c");
            assert_eq!(&deps[1], "test.h");
        }

        #[test]
        fn case1() {
            let (target, deps) = parse_deps(
                r#"test.o: test.c   \
 /usr/include/json/json\ parser.h \
 /usr/include/stdio.h     \
   ../includes/config.h test.h
"#,
            )
            .unwrap();
            assert_eq!(target, "test.o");
            assert_eq!(deps.len(), 5);
            assert_eq!(&deps[0], "test.c");
            assert_eq!(&deps[1], "/usr/include/json/json parser.h");
            assert_eq!(&deps[2], "/usr/include/stdio.h");
            assert_eq!(&deps[3], "../includes/config.h");
            assert_eq!(&deps[4], "test.h");
        }
    }
}
